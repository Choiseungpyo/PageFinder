using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.AI;
using Random = UnityEngine.Random;
using UnityEngine.InputSystem.LowLevel;
using static UnityEditor.ShaderGraph.Internal.KeywordDependentCollection;
using static UnityEngine.ParticleSystem;

public class EnemyAction : EnemyAnimation
{
    #region Enemy Coroutine
    protected override IEnumerator EnemyCoroutine()
    {
        while (!isDie)
        {
            // 플레이어가 죽었을 경우
            if (playerObj == null)
                break;

            Action();
            Animation();
            yield return null;
        }
    }

    protected void Action()
    {
        // 쿨타임 계산
        SetAllCoolTime();

        // 경직(didPerceive 그대로), 넉백(didPerceive 그대로)
        // 속박(didPerceive 그대로), 기절(didPerceive = false)
        if (state == State.DEBUFF && debuffState != DebuffState.NONE)
            return;

        // idle 상태에서는 Idle 애니메이션이 끝나고 어떠한 상태로 변함
        // 그러므로 Idle 애니메이션 상태에서는 어떠한 동작으로 변하지 않도록 함
        if (state == State.IDLE && idleState != IdleState.NONE)
            return;

        // 공격 상태가 되면 공격이 끝나야 attackState가 None으로 변경됨
        // 공격 애니메이션 도중 움직이지 않도록 설정하기 위함
        if (state == State.ATTACK && attackState != AttackState.NONE)
            return;

        SetRootState();
        SetDetailState();
    }
    #endregion

    #region State

    protected virtual void SetRootState()
    {
        float distance = Vector3.Distance(playerObj.transform.transform.position, enemyTr.position);

        switch (attackDistType)
        {
            case AttackDistType.SHORT:
                // 플레이어를 인지했을 경우
                if (didPerceive)
                {
                    if (distance <= cognitiveDist)
                    {
                        // 플레이어가 앞에 있는 경우
                        if (CheckPlayerInFrontOfEnemy())
                            state = State.ATTACK;
                        else
                            state = State.MOVE; // 회전
                    }
                    else
                        state = State.MOVE;
                }
                else
                {
                    if (distance <= cognitiveDist)
                    {
                        // 플레이어가 앞에 있는 경우
                        if (CheckPlayerInFrontOfEnemy())
                        {
                            didPerceive = true;
                            state = State.IDLE; // 공격 대기
                        }
                        else
                            state = State.MOVE; // 회전

                        //Debug.Log("RootState didPerceive False : 인지거리 안에 있음");
                    }
                    else
                    {
                        distance = Vector3.Distance(enemyTr.position, currDestination);

                        if (distance <= 1)
                            state = State.IDLE; // 순찰 대기
                        else
                            state = State.MOVE; // 순찰

                        //Debug.Log($"RootState didPerceive False  Diestance{distance}: {state}");
                    }
                }
                break;

            case AttackDistType.LONG:
                // 플레이어를 인지했을 경우
                if (didPerceive)
                {
                    if (IsEnemyInCamera())
                    {
                        // 플레이어가 앞에 있는 경우
                        if (CheckPlayerInFrontOfEnemy())
                            state = State.ATTACK;
                        else
                            state = State.MOVE; // 회전
                    }
                    else
                        state = State.MOVE;
                }
                else
                {
                    if (IsEnemyInCamera())
                    {
                        // 플레이어가 앞에 있는 경우
                        if (CheckPlayerInFrontOfEnemy())
                        {
                            didPerceive = true;
                            state = State.IDLE; // 공격 대기
                        }
                        else
                            state = State.MOVE; // 회전

                        //Debug.Log("RootState didPerceive False : 인지거리 안에 있음");
                    }
                    else
                    {
                        distance = Vector3.Distance(enemyTr.position, currDestination);

                        if (distance <= 1)
                            state = State.IDLE; // 순찰 대기
                        else
                            state = State.MOVE; // 순찰

                        //Debug.Log($"RootState didPerceive False  Diestance{distance}: {state}");
                    }
                }
                break;
        }
    }

    protected void SetDetailState()
    {
        switch (state)
        {
            case State.IDLE:
                moveState = MoveState.NONE;
                attackState = AttackState.NONE;
                debuffState = DebuffState.NONE;

                SetIdleState();
                SetAgentData(transform.position);
                break;

            case State.MOVE:
                attackState = AttackState.NONE;
                debuffState = DebuffState.NONE;

                SetMoveState();
                SetMoveAction();
                break;

            case State.ATTACK:
                moveState = MoveState.NONE;
                debuffState = DebuffState.NONE;

                SetAttackState();
                SetAgentData(transform.position);
                break;

            case State.DEBUFF:
                moveState = MoveState.NONE;
                attackState = AttackState.NONE;

                SetAgentData(transform.position);
                break;

            case State.DIE:
                moveState = MoveState.NONE;
                attackState = AttackState.NONE;
                debuffState = DebuffState.NONE;

                SetAgentData(transform.position);
                break;
        }
    }

    private void SetIdleState()
    {
        // IdleState.First : 맨 처음 시작시, Stun이 끝난 후에 동작
        // 그러므로 이 함수 내부로 들어오지 않으므로 따로 처리하지 않는다.
        if (didPerceive)
            idleState = IdleState.ATTACKWAIT;
        else
            idleState = IdleState.PATROLWAIT;
    }

    private void SetMoveState()
    {
        float distance = Vector3.Distance(playerObj.transform.transform.position, enemyTr.position);
        switch (attackDistType)
        {
            case AttackDistType.SHORT:
                // 플레이어를 인지했을 경우
                if (didPerceive)
                {
                    // 회피형인 경우
                    if (personality == Personality.PATROL)
                    {
                        moveState = MoveState.RUN;
                        return;
                    }

                    if (distance <= cognitiveDist)
                    {
                        // 플레이어가 앞에 있지 않은 경우
                        if (!CheckPlayerInFrontOfEnemy())
                            moveState = MoveState.ROTATE;
                    }
                    else
                        moveState = MoveState.CHASE;
                }
                else
                {
                    if (distance <= cognitiveDist)
                    {
                        // 회피형인 경우
                        if (personality == Personality.PATROL)
                        {
                            moveState = MoveState.RUN;
                            return;
                        }

                        // 플레이어가 앞에 있지 않은 경우
                        if (!CheckPlayerInFrontOfEnemy())
                            moveState = MoveState.ROTATE;
                    }
                    else
                    {
                        distance = Vector3.Distance(enemyTr.position, currDestination);

                        if (distance > 1)
                            moveState = MoveState.PATROL;
                    }
                }
                break;

            case AttackDistType.LONG:
                // 플레이어를 인지했을 경우
                if (didPerceive)
                {
                    // 회피형인 경우
                    if (personality == Personality.PATROL)
                    {
                        moveState = MoveState.RUN;
                        return;
                    }

                    if (IsEnemyInCamera())
                    {
                        // 플레이어가 앞에 있지 않은 경우
                        if (!CheckPlayerInFrontOfEnemy())
                            moveState = MoveState.ROTATE;

                        // 플레이어와 거리가 n칸 이내일 경우 도망로직 추가해야 함 
                    }
                    else
                        moveState = MoveState.NONE;
                }
                else
                {
                    if (IsEnemyInCamera())
                    {
                        // 회피형인 경우
                        if (personality == Personality.PATROL)
                        {
                            moveState = MoveState.RUN;
                            return;
                        }

                        // 플레이어가 앞에 있지 않은 경우
                        if (!CheckPlayerInFrontOfEnemy())
                            moveState = MoveState.ROTATE;
                    }
                    else
                    {
                        distance = Vector3.Distance(enemyTr.position, currDestination);

                        if (distance > 1)
                            moveState = MoveState.PATROL;
                    }
                }
                break;
        }
       
    }


    protected virtual void SetAttackState()
    {
        // 하급 적은 기본공격만 존재
        attackState = AttackState.BASIC;
    }

    #endregion

    #region Action 관련

    private void SetMoveAction()
    {
        switch (moveState)
        {
            case MoveState.NONE:
                break;

            case MoveState.PATROL:
                currDestination = patrolDestinations[patrolDestinationIndex];
                SetAgentData(currDestination, false);
                break;

            case MoveState.ROTATE:
                currDestination = transform.position;
                SetAgentData(currDestination, false, false);
                Rotate();
                break;

            case MoveState.CHASE:
                currDestination = playerObj.transform.position;
                SetAgentData(currDestination, false);
                break;

            case MoveState.RUN:
                SetAgentData(currDestination, false);
                break;

            default:
                SetAgentData(currDestination, false);
                Debug.LogWarning(moveState);
                break;
        }
    }


    protected virtual void BasicAttack()
    {
        // 히트 박스 활성화 코드로 바꾸기

        float distance = Vector3.Distance(playerObj.transform.position, enemyTr.position);

        if (distance <= cognitiveDist)
            playerState.CurHp -= atk;
    }

    /// <summary>
    /// 기본 공격 애니메이션 종료 후 동작
    /// </summary>
    protected virtual void BasicAttackEnd()
    {
        attackState = AttackState.NONE;
    }

    #endregion

    #region CoolTime
    protected virtual void SetAllCoolTime()
    {
        SetIdleTime();
        SetDebuffTime();
    }

    private void SetIdleTime()
    {
        if (state == State.IDLE && idleState == IdleState.NONE)
            return;

        switch (idleState)
        {
            case IdleState.FIRSTWAIT:
                if(currFirstWaitTime > 0)
                {
                    currFirstWaitTime -= Time.deltaTime;
                    return;
                }

                currFirstWaitTime = maxFirstWaitTime;
                state = State.MOVE; // patrol
                break;

            case IdleState.PATROLWAIT:
                if (currPatrolWaitTime > 0)
                {
                    currPatrolWaitTime -= Time.deltaTime;
                    return;
                }

                PatrolDestinationIndex += 1;
                currDestination = patrolDestinations[PatrolDestinationIndex];
                currPatrolWaitTime = maxPatrolWaitTime;
                state = State.MOVE; // patrol
                break;

            case IdleState.ATTACKWAIT:
                if (currAttackWaitTime > 0)
                {
                    currAttackWaitTime -= Time.deltaTime;
                    return;
                }
               
                currAttackWaitTime = maxAttackWaitTime;
                state = State.ATTACK; // attack
                break;
        }
        idleState = IdleState.NONE;
    }

    private void SetDebuffTime()
    {
        if (state != State.DEBUFF)
            return;

        if (currDebuffTime < 0)
        {
            state = State.IDLE;
            return;
        }

        currDebuffTime -= Time.deltaTime;
    }

    #endregion

    #region Rotate
    private void Rotate()
    {
        Vector3 dir = (playerObj.transform.position - 
            new Vector3(enemyTr.position.x, playerObj.transform.position.y, enemyTr.position.z)).normalized;

        enemyTr.rotation = Quaternion.Slerp(enemyTr.rotation, Quaternion.LookRotation(dir), 7f * Time.deltaTime); 
        // 시간에 따른 회전 속도값을 플레이어 움직임 속도에 비례하여 바로 플레이어 쪽을 바라볼 수 있도록 나중에 설정하기
        // 현재는 플레이어가 계속 빙글빙글 돌면 공격못하고 회전만 함, 이게 Slerp의 문제일 수도 있을 듯
    }

    protected bool CheckPlayerInFrontOfEnemy()
    {
        Vector3 pos = new Vector3(enemyTr.position.x, playerObj.transform.position.y, enemyTr.position.z); 

        switch(attackDistType)
        {
            case AttackDistType.SHORT:
                // 적의 정면에 플레이어가 존재할 경우
                if (Physics.Raycast(pos, enemyTr.forward, cognitiveDist, LayerMask.GetMask("PLAYER")))
                    return true;
                else
                    return false;

            case AttackDistType.LONG:
                // 적의 정면에 플레이어가 존재할 경우
                if (Physics.Raycast(pos, enemyTr.forward, Vector3.Distance(enemyTr.position, playerObj.transform.position), LayerMask.GetMask("PLAYER")))
                    return true;
                else
                    return false;

            default:
                return false;
        }
    }
    #endregion

    #region Long Distance Attack Enemy
    protected void SetBullet(GameObject bulletPrefab, int angle, float damage)
    {
        Vector3 targetDir = Quaternion.AngleAxis(angle, Vector3.up) * enemyTr.forward;
        Vector3 spawnPos = enemyTr.position + targetDir;
        spawnPos.y = playerObj.transform.position.y + 1;
        GameObject bullet = Instantiate(bulletPrefab, spawnPos, Quaternion.identity); // Witched 앞에 세 갈래(-60,0,60)로 총알 생성
        Bullet bulletScr = DebugUtils.GetComponentWithErrorLogging<Bullet>(bullet, "Bullet");
        bulletScr.Damage = damage;

        Vector3 targetPos = enemyTr.position + targetDir * 100; // 해당 방향으로 맵 바깥까지 지점이 설정될 수 있도록 *100으로 설정
        bulletScr.Fire(targetPos);
    }

    private bool IsEnemyInCamera()
    {
        Vector3 enemyUIPos =  Camera.main.WorldToViewportPoint(enemyTr.position);

        if (enemyUIPos.x >= 0 && enemyUIPos.x <= 1 && enemyUIPos.y >= 0 && enemyUIPos.y <= 1 && enemyUIPos.z > 0)
            return true;
        return false;
    }

    #endregion

    private void SetAgentData(Vector3 pos, bool isStop = true, bool isRotate = true)
    {
        //if (!agent.isOnNavMesh)
        //{
        //    Debug.LogError("AgenTdata : NavMeshAgent가 NavMesh 위에 있지 않습니다! Base Offset을 확인하세요.");
        //}

        agent.destination = pos;
        agent.isStopped = isStop;
        agent.updateRotation = isRotate;
    }
}